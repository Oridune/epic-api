import { parse } from "flags";
import { dirname, isAbsolute, join } from "path";
import { existsSync, expandGlob } from "dfs";
import e, { ValidationException } from "validator";

import { Loader, SupportedEnv } from "@Core/common/loader.ts";
import { EnvType } from "@Core/common/env.ts";
import { Input } from "cliffy:prompt";
import { run } from "./lib/run.ts";

export enum PluginSource {
  GIT = "git",
}

export const resolvePluginName = (name: string) =>
  name
    .split("/")
    .filter(Boolean)
    .join("/")
    .split("\\")
    .filter(Boolean)
    .join("\\");

export const addPluginToImportMap = async (
  name: string,
): Promise<{
  imports: Record<string, string>;
  scopes: Record<string, Record<string, string>>;
}> => {
  const ImportMapPath = join(Deno.cwd(), "import_map.json");
  const PluginImportMapPath = join(
    Deno.cwd(),
    "plugins",
    name,
    "import_map.json",
  );
  const RelativePluginPath = `./plugins/${name}/`;

  const ImportMap = (
    await import(`file:///${ImportMapPath}`, {
      with: { type: "json" },
    })
  ).default;

  ImportMap.imports = {
    ...ImportMap.imports,
    [`@Plugins/${name}/`]: RelativePluginPath,
  };

  ImportMap.scopes = {
    ...ImportMap.scopes,
    [RelativePluginPath]: {},
  };

  const PluginImportMap = (
    await import(`file:///${PluginImportMapPath}`, {
      with: { type: "json" },
    })
  ).default;

  const ImportKeys = Object.keys(ImportMap.imports ?? {});
  const PluginImportKeys = Object.keys(PluginImportMap.imports ?? {});

  for (
    const Key of PluginImportKeys.filter(
      (key) => !ImportKeys.includes(key) || /@(-?\w+\/?)+/.test(key),
    )
  ) {
    if (!/^@((Plugin|Core)\/.*|Database)$/.test(Key)) {
      const TempPath = PluginImportMap.imports?.[Key];

      let ResolvedPath = TempPath;

      let IsUrl: boolean;

      try {
        new URL(TempPath);
        IsUrl = true;
      } catch {
        IsUrl = false;
      }

      const IsAbsolute = !IsUrl && isAbsolute(TempPath);
      const IsRelative = !IsUrl && !IsAbsolute;

      if (IsRelative) {
        ResolvedPath = `./${
          join(`./plugins/${name}/`, TempPath).replace(
            /\\/g,
            "/",
          )
        }`;
      }

      ImportMap.scopes[RelativePluginPath][Key] = ResolvedPath;
    }
  }

  await Deno.writeTextFile(
    ImportMapPath,
    JSON.stringify(ImportMap, undefined, 2),
  );

  return ImportMap;
};

export const updatePluginDeclarationFile = async () => {
  const DeclarationFilePath = join(Deno.cwd(), "plugins.d.ts");
  const PluginsName = Loader.getSequence("plugins")?.includes() ?? [];

  let DeclarationFileContent =
    "//! Warning: This is an auto-generated file! Please do not edit this file.";

  for (const PluginName of PluginsName) {
    const RelativePluginDeclarationPath = `./plugins/${PluginName}/index.d.ts`;

    if (existsSync(RelativePluginDeclarationPath)) {
      DeclarationFileContent +=
        `\n/// <reference types="${RelativePluginDeclarationPath}" />`;
    }
  }

  await Deno.writeTextFile(DeclarationFilePath, DeclarationFileContent);

  return DeclarationFileContent;
};

export const setupPlugin = async (opts: {
  env?: SupportedEnv;
  source: PluginSource;
  branch: string;
  name: string;
  sourcePath: string;
  targetPath: string;
}) => {
  // Create Files
  for (
    const Glob of ["**/**/*"].map((pattern) =>
      expandGlob(pattern, {
        root: opts.sourcePath,
        globstar: true,
      })
    )
  ) {
    for await (const Entry of Glob) {
      // Do not copy any file or folder from this list
      if (
        !Entry.isDirectory && [
          /^(\\|\/)?(\.git)(\\|\/)?/,
          /^(\\|\/)?(\.vscode)(\\|\/)?/,
          /^(\\|\/)?(\.husky)(\\|\/)?/,
          /^(\\|\/)?(core)(\\|\/)?/,
          /^(\\|\/)?(docs)(\\|\/)?/,
          /^(\\|\/)?(env)(\\|\/)?/,
          /^(\\|\/)?(tests)(\\|\/)?/,
          /^(\\|\/)?(terraform)(\\|\/)?/,
          /^(\\|\/)?(database.ts)/,
          /^(\\|\/)?(i18next.ts)/,
          /^(\\|\/)?(serve.ts)/,
          /^(\\|\/)?(deno.json)/,
          /^(\\|\/)?(\.lintstagedrc.json)/,
          /^(\\|\/)?(\.dockerignore)/,
          /^(\\|\/)?(docker-compose.yml)/,
          /^(\\|\/)?(docker-compose.yml)/,
          /^(\\|\/)?(Dockerfile)/,
          /^(\\|\/)?(new.README.md)/,
        ].reduce(
          (allow, expect) =>
            allow && !expect.test(Entry.path.replace(opts.sourcePath, "")),
          true,
        )
      ) {
        const SourcePath = Entry.path;
        const TargetPath = SourcePath.replace(
          opts.sourcePath,
          opts.targetPath,
        );

        const TargetDirectory = dirname(TargetPath);

        await Deno.mkdir(TargetDirectory, { recursive: true }).catch(
          () => {
            // Do nothing...
          },
        );

        await Deno.copyFile(SourcePath, TargetPath);
      }
    }
  }

  await Loader.getSequence("plugins")?.add(opts.name, {
    source: opts.source,
    branch: opts.branch,
  }, { env: opts.env });

  await addPluginToImportMap(opts.name);
};

export const addPlugin = async (options: {
  env?: SupportedEnv;
  source?: PluginSource;
  name: string | string[];
  branch?: string;
  prompt?: boolean;
}) => {
  try {
    const Options = await e
      .object(
        {
          env: e.optional(e.in(Object.values(EnvType))).default(
            "global" as const,
          ),
          source: e.optional(e.enum(Object.values(PluginSource)))
            .default(PluginSource.GIT),
          name: e.optional(e.array(e.string(), { cast: true, splitter: "," }))
            .default(async (ctx) =>
              ctx.parent!.input.prompt
                ? [
                  await Input.prompt({
                    message: "Name of the Plugin",
                  }),
                ]
                : undefined
            ),
          branch: e.optional(e.string()).default(options.branch ?? "main"),
          ignoreIfExists: e.optional(e.boolean()),
        },
        { allowUnexpectedProps: true },
      )
      .validate(options);

    if (Options.name) {
      const PluginsDir = join(Deno.cwd(), "plugins");

      for (const PluginId of Options.name) {
        const [PluginName, Branch] = PluginId.split(":");

        const ResolvedPluginName = resolvePluginName(PluginName);
        const ResolvedBranch = Branch ?? Options.branch;

        // Check if plugin already exists.
        if (Loader.getSequence("plugins")?.includes().has(ResolvedPluginName)) {
          if (Options.ignoreIfExists) continue;

          throw new Error(
            `The plugin '${ResolvedPluginName}' already exists on this project!`,
          );
        }

        const GitRepoUrl = new URL(ResolvedPluginName, "https://github.com");
        const TempPath = join(Deno.cwd(), "_temp", ResolvedPluginName);

        const clonePlugin = () =>
          setupPlugin({
            source: Options.source,
            branch: ResolvedBranch,
            name: ResolvedPluginName,
            env: Options.env,
            sourcePath: TempPath,
            targetPath: join(PluginsDir, ResolvedPluginName),
          });

        if (!existsSync(join(TempPath, "deno.json"))) {
          const [command, commandOptions] = Options.source === PluginSource.GIT
            ? [
              "git",
              {
                // Clone repository from Git.
                args: [
                  "clone",
                  "--single-branch",
                  "--branch",
                  ResolvedBranch,
                  GitRepoUrl.toString(),
                  TempPath,
                ],
              },
            ]
            : ["unknown", {}];

          const AddPlugin = await run(command, commandOptions);

          if (AddPlugin.success) await clonePlugin();
          else throw new Error("We were unable to add plugin(s)!");
        } else await clonePlugin();

        console.info("Plugin(s) added successfully!");
      }

      await updatePluginDeclarationFile();
    }
  } catch (error) {
    if (error instanceof ValidationException) {
      console.error(error, error.issues);
    }

    throw error;
  }
};

if (import.meta.main) {
  const { source, s, name, n, env } = parse(Deno.args);

  await Loader.load({ includeTypes: ["plugins"], sequenceOnly: true });

  await addPlugin({
    source: source ?? s,
    name: name ?? n,
    env,
    prompt: true,
  });

  Deno.exit();
}
